use openssl::{
    pkey::{Id, PKey},
    x509::X509,
};
use pem;

use super::{PkiBackend, PkiBackendInner, types};
use crate::{
    errors::RvError,
    logical::{Backend, Field, FieldType, Operation, Path, Request, Response},
    modules::RequestExt,
    storage::StorageEntry,
    utils::{cert, cert::CertBundle},
};

impl PkiBackend {
    pub fn config_ca_path(&self) -> Path {
        let backend = self.inner.clone();

        Path::builder()
            .pattern("config/ca")
            .field(
                "pem_bundle",
                Field::builder()
                    .field_type(FieldType::Str)
                    .description("PEM-format, concatenated unencrypted secret key and certificate"),
            )
            .operation(Operation::Write, {
                let handler = backend.clone();
                move |backend, req| {
                    let handler = handler.clone();
                    Box::pin(async move { handler.write_path_ca(backend, req).await })
                }
            })
            .help(
                r#"
This configures the CA information used for credentials
generated by this backend. This must be a PEM-format, concatenated
unencrypted secret key and certificate.

For security reasons, you can only view the certificate when reading this endpoint
"#,
            )
            .build()
    }
}

impl PkiBackendInner {
    pub async fn write_path_ca(
        &self,
        _backend: &dyn Backend,
        req: &mut Request,
    ) -> Result<Option<Response>, RvError> {
        let payload: types::ConfigCaRequest = req.parse_json()?;
        let pem_bundle = payload.pem_bundle.as_str();

        let items = pem::parse_many(pem_bundle)?;
        let mut key_found = false;
        let mut i = 0;

        let mut cert_bundle = CertBundle::default();

        for item in items {
            if item.tag() == "CERTIFICATE" {
                let cert = X509::from_der(item.contents())?;
                if !cert::is_ca_cert(&cert) {
                    return Err(RvError::ErrPkiPemBundleInvalid);
                }

                if i == 0 {
                    cert_bundle.certificate = cert;
                } else {
                    cert_bundle.ca_chain.push(cert);
                }
                i += 1;
            }
            if item.tag() == "PRIVATE KEY" {
                if key_found {
                    return Err(RvError::ErrPkiPemBundleInvalid);
                }

                let key = PKey::private_key_from_der(item.contents())?;
                match key.id() {
                    Id::RSA => {
                        cert_bundle.private_key_type = "rsa".to_string();
                    }
                    Id::EC => {
                        cert_bundle.private_key_type = "ec".to_string();
                    }
                    Id::SM2 => {
                        cert_bundle.private_key_type = "sm2".to_string();
                    }
                    Id::ED25519 => {
                        cert_bundle.private_key_type = "ed25519".to_string();
                    }
                    _ => {
                        cert_bundle.private_key_type = "other".to_string();
                    }
                }
                cert_bundle.private_key = key;
                key_found = true;
            }
        }

        cert_bundle.verify()?;

        self.store_ca_bundle(req, &cert_bundle).await?;

        let entry = StorageEntry {
            key: "crl".to_string(),
            value: Vec::new(),
        };

        req.storage_put(&entry).await?;

        Ok(None)
    }

    pub async fn fetch_ca_bundle(&self, req: &Request) -> Result<CertBundle, RvError> {
        let entry = req.storage_get("config/ca_bundle").await?;
        if entry.is_none() {
            return Err(RvError::ErrPkiCaNotConfig);
        }

        let ca_bundle: CertBundle = serde_json::from_slice(entry.unwrap().value.as_slice())?;
        Ok(ca_bundle)
    }

    pub async fn store_ca_bundle(
        &self,
        req: &mut Request,
        ca_bundle: &CertBundle,
    ) -> Result<(), RvError> {
        let mut entry = StorageEntry::new("config/ca_bundle", ca_bundle)?;

        req.storage_put(&entry).await?;

        entry.key = "ca".to_string();
        entry.value = ca_bundle.certificate.to_pem().unwrap();
        req.storage_put(&entry).await?;

        let serial_number_hex = ca_bundle.serial_number.replace(':', "-").to_lowercase();
        self.store_cert(req, &serial_number_hex, &ca_bundle.certificate)
            .await?;

        Ok(())
    }

    pub async fn delete_ca_bundle(&self, req: &Request) -> Result<(), RvError> {
        let ca_bundle = self.fetch_ca_bundle(req).await?;
        let serial_number_hex = ca_bundle.serial_number.replace(':', "-").to_lowercase();

        self.delete_cert(req, &serial_number_hex).await?;

        req.storage_delete("config/ca_bundle").await?;

        Ok(())
    }
}
